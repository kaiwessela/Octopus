TODO:
- bei conditions überprüfen, ob das betreffende feld included ist oder nicht
- order neu organisieren. relationshiplists können nicht geordnet werden.
- url matching: testen, ob die url auch wirklich mit dem letzten segment aufhört.

- Kollisionstests (Einzigartigkeit) für Relationships
- Neuorganisation von DatabaseAccess-Provision
- next und prev für Pagination
- new/better auth/permission system
- remove and reorganize Config::SERVER_URL
- use transactions on Entity::push()



----------------
Idee: DataObjectCollection
- gespeichert als JSON in einem Container-Objekt
	-> Mischung aus DataObject und DataType
- Format:
	{
		type_1: [object_id_1, object_id_2, …],
		type_2: …,
		…
	}
	oder
	{
		name_1: {'type': type_1, 'ids' => [object_id_1, object_id_2], (options/tags: […])}
		…
	}
- Jeder Typ wird einzeln gepullt; Dafür sind neue Pull-Funktionen zumindest in DataObjectLists nötig,
	die das Pullen einer spezifischen Liste von IDs erlauben.
- Objekte und evtl. auch Listen sollen in Markdown-Text eingebunden werden können, z.B. per [[object]].
	-> erfordert neuen MarkdownContent, der zum Parsen Templates mitgegeben werden müssen.
		Ähnlich wie bei den each-Funktionen. Bei fehlenden Templates wird das Objekt ignoriert.
		(evtl. mit Umschaltung, ob ignoriert oder die ID ausgegeben werden soll)
